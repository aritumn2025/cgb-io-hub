# LAN 内スマホコントローラ仕様書（Go ハブ＋ Unity クライアント／MVP）

## 0. 概要（Purpose）

**目的**: 同一 LAN 内でスマホの Web アプリをゲーム用コントローラーとして使用する。PC 側のゲーム（Unity Windows ビルド）とスマホ（ブラウザ）は、**Go 製ハブサーバ**を介して**WebSocket**で低遅延通信を行う。まずは**MVP**として単純・堅牢・拡張容易な仕様を定義する。

## 1. 用語定義（Glossary）

- **Hub**: Go で実装するハブサーバ。HTTP（UI 配布）と WebSocket（リアルタイム）を提供。
- **Controller**: スマホの Web UI（送信側）。ユーザのタッチ/ボタン入力を送出。
- **Game**: Unity ビルド（受信側）。Hub から入力を受け取り、ゲームへ反映。
- **Session**: Hub における接続の論理単位。`role` と `id` を持つ。
- **Room**（将来）: 複数の Game/Controller を分離する論理空間。MVP では 1 Room 固定。

## 2. スコープ（Scope）

### 2.1 In Scope（MVP）

- 同一 LAN 内での **1 台の Game** と **最大 4 台の Controller** の接続/操作（4 人固定）
- Hub が配布する Web ページからの UI 操作（タッチスティック＋ A ボタン）
- WebSocket を用いた低遅延入力伝送（おおむね 60Hz 以下）
- 再接続／切断ハンドリング（自動再接続）
- 簡易なペアリング（`role` と `id` のみ）
- 最低限の観測性（ログ、/healthz）

### 2.2 Out of Scope（MVP では非対象）

- インターネット越し通信／NAT 越え（→ WebRTC/TURN: 将来）
- TLS/認証（→ ローカル LAN のみ想定。将来対応）
- 高度な入力（モーションセンサー、複合ジェスチャ）
- ゲーム側での「仮想デバイス」実装（Unity Input System 正式統合）。MVP は自前変数反映で十分。

## 3. ユースケース（User Stories）

1. プレイヤーはスマホで同一 Wi‑Fi に接続し、`http://<HubのLAN IP>:8765/` を開くとコントローラ UI が表示される。（**最大 4 人**まで同時参加可）
2. プレイヤーがスティックやボタンを操作すると、即時に Game へ入力が反映される。
3. Game が起動していない/切断された場合でも、Controller は自動で待機/再接続する。
4. 複数プレイヤー（〜4 台）が同時に接続しても、入力は各 `id` ごとに識別される。

## 4. 非機能要件（NFR）

- **遅延**: **TBD（要合意）**。暫定ターゲットは p95 50ms 以下（Controller タップ →Game 反映まで、LAN 5GHz 想定）
- **スループット**: Controller 1 台あたり 30〜60 msg/sec を上限とし、Hub/Unity で Coalesce（詰まり防止）
- **可用性**: 同一 LAN でのローカル運用。Hub/Unity どちらか再起動しても自動復旧
- **拡張性**: 将来の TLS/認証、Room、多人数、WebRTC へ移行可能な設計
- **運用**: Windows サービス/常駐での運用を見据え、標準出力 JSON ログ＋/healthz

## 5. アーキテクチャ（Architecture）

```
[Controller (WebUI)] --WS--> [Hub (Go)] --WS--> [Game (Unity)]
          ^  HTTP (UI配布)  |
          +-----------------+
```

- **通信**: WebSocket（Text JSON）。LAN 内で TCP 安定性を優先
- **接続モデル**: Game は Hub へ 1 本、Controller は複数本。Hub は Controller→Game への中継を主とする

## 6. ネットワーク・ポート・URL

- HTTP: `:8765`（UI 配布: `/`）
- WS: `:8765/ws`
- Healthcheck: `/healthz` → 200 OK（JSON 簡易）
- （将来）Metrics: `/metrics`（Prometheus 互換）

## 7. プロトコル仕様（WebSocket）

### 7.1 接続直後の登録メッセージ（必須）

**方向**: Client → Hub（最初の Text Frame）

```json
{ "role": "controller", "id": "p1" }
```

```json
{ "role": "game" }
```

- `role`: `controller`|`game`
- `id`: Controller の識別子（`p1` 等）。Game は省略可。

**バリデーション失敗**: Hub は Close（1008 Policy Violation）

### 7.2 Controller → Hub（入力状態）

```json
{
  "type": "state",
  "id": "p1",
  "axes": { "x": 0.1, "y": -0.7 },
  "btn": { "a": true },
  "t": 1690000000000
}
```

- `axes.x|y`: -1.0〜1.0（3 桁程度で丸め推奨）
- `btn`: 各ボタンの真偽
- `t`: Controller 側での送信 UNIX ms（遅延計測用）

### 7.3 Hub → Game（中継）

- 原則 **無改変**で中継。
- Hub は送信キューが詰まる場合、**最新優先**で古い入力をドロップ（Backpressure 制御）。

### 7.4 エラーイベント（将来拡張）

```json
{ "type": "error", "code": "INVALID_PAYLOAD", "detail": "axes.x missing" }
```

### 7.5 ハートビート

- WS の Tickle に加え、Controller は 2〜5 秒に 1 回 `state` を最低送出（停止検知のため）

## 8. HTTP エンドポイント

- `GET /` : Controller UI（単一 HTML + JS + CSS）
- `GET /healthz` : `{ "ok": true }` を返す
- `GET /qrcode`（将来）: ハブの LAN URL を QR 生成して返す

## 9. Hub（Go）

### 9.1 ランタイム/依存

- Go 1.24+（Linter 通過）
- WebSocket: `nhooyr.io/websocket`
- `embed`で静的ファイル配布

### 9.2 設定（優先順位: Flag > Env > デフォルト）

- `--addr`（ENV: `ADDR`）: 例 `:8765`
- `--origins`（ENV: `ORIGINS`）: 許可 Origin（MVP は`*`）
- `--max-clients` : Controller 接続上限（既定 8）
- `--rate-hz` : 中継上限（既定 60）

### 9.3 ロギング

- 構造化 JSON（level, ts, msg, remote_ip, role, id）
- ログローテーションは外部（logrotate/rotatelogs）前提

### 9.4 ステート

- `gameConn`（単一）
- `controllers`（map[id]Conn）※MVP は中継なので保持は任意
- 送信キュー（bounded, 最新優先）

### 9.5 エラー/Close コード

- 1000 Normal, 1008 Policy, 1011 Internal
- HTTP 400/403/500 も適宜

## 10. Controller（Web UI）

### 10.1 対応ブラウザ

- iOS Safari 16+ / Android Chrome 115+（Pointer Events 対応）

### 10.2 入力 UI

- 左: 円形スティック（ドラッグで-1〜1）
- 右: ボタンクラスタ（A ボタン）
- ただし**最終的なボタン構成はゲームのキーバインドに一致**させる（§10.5）
- バイブレーション（対応端末）
- Wake Lock（対応端末）

### 10.3 再接続

- 切断時は指数的バックオフ（0.8s〜3s）で自動再接続

### 10.4 レート制御

- ポインタ移動時のみ即送信
- 連続未操作時は 2〜5 秒に 1 回ハートビート

### 10.5 ボタン構成**（TBD: キーバインド同定計画）**

- 現状ビルド（zip）から**静的にキーバインドを抽出できる確証が無い**ため、以下いずれかで確定する：

  1. **ランタイム観測**: 一時的にキー入力をフックする診断シーン/ビルドを用意し、押下キーのログを採取（推奨）
  2. **ソース確認**: Project の Input System/旧 InputManager/スクリプトを参照
  3. **手動リスト**: 現在の操作表（P1〜P4 のキーボード割当）を共有

- 確定後、Web UI に **同名/同機能ボタン** を配置し、`btn` ペイロードに列挙（例: `jump`, `dash`, `shoot`, `pause` など）

## 11. Game（Unity）

### 11.1 受信

- 起動時に Hub へ WS 接続・`{"role":"game"}` を送出
- 受信メッセージをキューへ格納し、`Update()`で逐次反映

### 11.2 入力反映

- **MVP**: `axisX/axisY/btnA` を自前の変数に反映し、移動・アクションへ適用
- **将来**: Unity Input System の仮想デバイス化（`InputSystem.QueueStateEvent`）

### 11.3 複数プレイヤー

- `id` ごとに入力を保持し、キャラクターやスロットへマッピング（**`p1..p4`の 4 人固定**）

## 12. セキュリティ/プライバシー

- **MVP**: **LAN 内のみ**、認証なし、CORS/Origin は`*`（デモ以上の公開 NG）
- **将来**:

  - ローカル TLS（mkcert 等）
  - ワンタイム PIN/QR ペアリング
  - Origin/同一サブネット制限

## 13. 遅延・品質要件（測定方法含む）

- **目標**: Controller タップ →Game 挙動 50ms p95 以下
- **計測**:

  - Controller の`t` と Game 受信時刻の差（Hub 通過時刻もログ）
  - 連続ドラッグ時のフレーム落ち（ドロップ率 < 1%）

## 14. 設計詳細（フロー）

### 14.1 接続シーケンス（MVP）

```
Controller        Hub                   Game
    |   HTTP GET / (UI)  |
    |------------------->|
    |                    |
    |  WS /ws (register: role=controller,id=p1)
    |------------------->|
    |                    |
    |                    |   WS /ws (register: role=game)
    |                    |<----------------------------    |  state(...)        |   relay state(...)
    |------------------->|------------------------------->
```

### 14.2 バックプレッシャ

- Hub→Game のキューは固定長。満杯時は古い`state`を破棄し、最新を優先。

## 15. コンフィグ/デプロイ/実行

### 15.1 Hub 実行

```
$ go build -o hub.exe
$ ./hub.exe --addr :8765
# ログに LAN IP 表示
```

### 15.2 Game

- `WsGameInput`（MonoBehaviour）をシーンに配置。`url` に `ws://<HubIP>:8765/ws`

### 15.3 Controller

- スマホで `http://<HubIP>:8765/` を開く。`?id=p2` 等で ID 指定可。

## 16. ロードマップ（拡張）

1. QR ペアリング（Game が QR 表示 → スマホがスキャン）
2. Room/Matchmaking（複数 Game の同居）
3. TLS + PIN 認証（ローカル認証）
4. WebRTC DataChannel（外出先対応・より低遅延）
5. Input System 仮想デバイス統合（統一入力パイプ）
6. PWA 化（ホーム画面、フルスクリーン）
7. 触覚/効果音フィードバックの強化

## 17. 参考実装の最小 I/F（ダイジェスト）

- `POST /healthz` ではなく `GET /healthz`（200/JSON）
- `WS /ws` 登録 →`state`中継
- 代表 Payload は §7 を参照

## 18. まとめ（平易な文）

同じ LAN にある PC で Go のハブを動かし、スマホの Web ページから入力を送って Unity で受け取る方式です。まずは ID 付きの`state`メッセージを中継するだけの MVP とし、遅延・再接続・複数端末の基本を固めます。うまく動いたら、TLS や QR ペアリング、Input System 統合、WebRTC などを段階的に足していきましょう。

## 19. クリーンアーキテクチャ適用指針（Domain/UseCase/Interface）

**前提**: B パターン（Go ハブ＋ Unity クライアント、LAN のみ、最大 4 人）に対して、ドメイン層を中心に**技術詳細から独立したモデル**を定義する。実装言語は Hub=Go、Game=Unity C#だが、**ドメインの語彙・不変条件を共有**し、各実装は Interface Adapters で吸収する。

### 19.1 Ubiquitous Language（共通語彙）

- **Room**: 入力の論理空間。MVP は`default`固定（将来は複数）。
- **Participant**: Room に属する接続主体。`Game` または `Controller`。
- **ControllerId**: `p1..p4` の識別子。`PlayerId`と同義で扱う。
- **InputState**: ある時点の入力状態（軸・ボタン・タイムスタンプ）。値オブジェクト。
- **InputStream**: ControllerId 単位で時間順に並ぶ InputState の列。
- **BackpressurePolicy**: キューが飽和したときの捨て方（最新優先）。
- **InactivityTimeout**: 無入力で不活性と見なすまでの時間。
- **LatencySample**: Controller 送信`t`と受信時刻の差分（遅延観測値）。

### 19.2 境界づけられたコンテキスト

- **Hub Context（Go）**: 接続管理・検証・中継・遅延観測・Backpressure。
- **Game Context（Unity）**: 受信・プレイヤーマッピング・ゲーム入力への適用（MVP は自前変数、将来は仮想デバイス）。

### 19.3 ドメインモデル（Hub）

**Entities / Aggregates**

- `Room`（集約ルート）

  - `id: RoomId`
  - `game: Optional<GameEndpoint>`
  - `controllers: map[ControllerId]ControllerEndpoint`
  - ルール: Game は 0..1、Controller は 0..4、Id は一意。

- `GameEndpoint`

  - `connId`（トランスポート依存の識別子）
  - `outbox: OutboxQueue`（Game 向け送信キュー）

- `ControllerEndpoint`

  - `id: ControllerId`
  - `connId`
  - `lastSeen: Time`

**Value Objects**

- `ControllerId`（列挙: p1..p4）
- `InputState`（axes{x,y}, btn{a} _→ 将来拡張で追加_ , t: UnixMillis）
- `LatencySample`（controllerId, sentAt, receivedAt）

**Domain Services**

- `Router`（Controller→Room→Game への配信規則、Backpressure 適用）
- `HealthPolicy`（InactivityTimeout によるエビクション判定）

**Policies**

- `BackpressurePolicy = LatestWins(capacity=N)`
- `InactivityTimeout = 10s`

**Domain Events（発火/購読の例）**

- `GameConnected`, `GameDisconnected`
- `ControllerJoined(controllerId)`, `ControllerLeft(controllerId)`
- `InputReceived(controllerId, inputState)`
- `InputDropped(controllerId, reason="backpressure")`

**Invariants（不変条件）**

- 同一 Room で`ControllerId`は重複不可。
- `InputState.axes ∈ [-1,1]`、`btn ∈ {true,false}`。
- Game 未接続時は`InputState`を蓄積しない（MVP）※将来はバッファ可。

### 19.4 アプリケーション層ユースケース（Hub）

- **RegisterGame**: Game 接続を Room へ登録。既存があれば置換。
- **RegisterController(id)**: `id ∈ {p1..p4}` を検証し登録。重複時は再接続ポリシーに従う（置換 or 拒否）。
- **SubmitInput(id, state)**: 正規化・検証 →Router へ発行 →Game の Outbox へ試行投入（Backpressure 適用）。
- **TickHealth**: `lastSeen`監視で不活性 Controller を退去。

**入出力ポート（Interface）**

- `GameOutboundPort` : `SendToGame([]byte) error`（非同期/キューリング）
- `ClockPort` : `Now() time.Time`
- `LoggerPort` : `Info/Error/WithFields(...)`
- `MetricsPort` : `ObserveLatency(sample)`, `CountDropped(...)`
- `RoomRepo` : `Load(RoomId)`, `Save(Room)`（MVP はメモリ）

### 19.5 トランスポート適合（Hub）

- **WebSocket Adapter（Inbound）**: `OnOpen`で`Register*`、`OnMessage`で`SubmitInput`、`OnClose`で退去。
- **WebSocket Adapter（Outbound）**: `GameOutboundPort`が Game 用コネクションに非同期送信。キューは`LatestWins`で実装。

### 19.6 ドメインモデル（Game）

**Entities**

- `PlayerSlot`（p1..p4）: 現在値 `InputState` を保持。

**UseCases**

- **ReceiveInput(state)**: `id`に応じて該当`PlayerSlot`を更新。
- **ApplyInputToGameLoop**: `Update()`で`PlayerSlot`の`InputState`を移動/アクションへ反映。

**Ports**

- `HubInboundPort`（WS 受信）
- `Mapper`（ControllerId→ キャラクタ）

### 19.7 エラーハンドリング/エラー語彙

- DomainError: `InvalidControllerId`, `DuplicateController`, `NoGameConnected`, `MalformedInput`, `QueueSaturated` など。
- Adapter 層では HTTP/WS のステータス/Close コードにマッピング（1008,1011,400,500）。

### 19.8 DTO/メッセージ契約（技術非依存の契約）

```jsonc
// Register (Controller)
{ "role": "controller", "id": "p1" }
// Register (Game)
{ "role": "game" }
// InputState
{
  "type": "state",
  "id": "p1",
  "axes": { "x": -1.0, "y": 1.0 },
  "btn":  { "a": false },
  "t": 1690000000000
}
```

※ ボタン構成は**キーバインド確定後に拡張**。拡張は後方互換（未知フィールド無視）。

### 19.9 参照実装スケルトン（抜粋）

**Go（ドメイン/ユースケースのポート）**

```go
// domain
type ControllerID string // "p1".."p4"

type InputState struct {
    Axes struct{ X, Y float32 }
    Btn  struct{ A bool }
    T    int64 // unix ms
}

type Room interface {
    RegisterGame(connID string) error
    RegisterController(id ControllerID, connID string) error
    SubmitInput(id ControllerID, st InputState) error
    TickHealth(now time.Time)
}

// usecase ports
type GameOutboundPort interface { SendToGame(payload []byte) error }
```

**C#（Game 側の境界）**

```csharp
public interface IInputReceiver {
    void Receive(InputState state); // from Hub
}

public struct InputState {
    public string id; // "p1".."p4"
    public Vector2 axes;
    public Buttons btn;
    public long t;
}
```

### 19.10 テスト方針（ドメイン）

- **ユニット**: Room の不変条件（ID 重複、Backpressure、Inactivity）
- **コンポーネント**: WebSocket Adapter をモック化し、Register/SubmitInput/TickHealth の振る舞い確認
- **契約テスト**: DTO スキーマの互換性（未知フィールド無視、必須フィールド欠落時のエラー）

### 19.11 マイグレーション/拡張の道筋

- ボタン拡張時は `btn` に機能名で追加（例:`jump`,`dash`）。旧 UI は既存 4 つだけ送る → 後方互換維持。
- Room を複数化する際は`roomId`を全メッセージに付与。
- 外出先対応では WebRTC シグナリングのポート/ポリシーを別 Adapter として追加（ドメイン変更最小）。

### Appendix B: 設定値テンプレ（.env）

```
ADDR=:8765
ORIGINS=*
MAX_CLIENTS=8
RATE_HZ=60
```

### Appendix C: チェックリスト（実装前）

- [ ] Hub 起動時に LAN IP 表示
- [ ] /healthz 実装
- [ ] /ws 登録 → 中継 →Backpressure
- [ ] Controller UI: Pointer/Buttons + WakeLock + Reconnect
- [ ] Game 受信スクリプト: キュー、例外ログ、Inspector 表示
- [ ] ログ: JSON 構造化
- [ ] 遅延簡易計測（t フィールド）
- [ ] **ボタン構成確定**（P1〜P4 キーバインドの同定 →UI 反映）
